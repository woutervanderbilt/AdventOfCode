using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Problems.Advent._2019;

public class Dag18 : Problem
{
    private const string input = @"#################################################################################
#...#.......#....a..#...........#..e....#.....#...#...#...........#.............#
#.#.#.#####.#.#####.#.#######.###.###.#.#.###.#.#.###.#.#########.#.###.#######.#
#.#.#.#.#...#.#.K...#...#...#.....#.#.#.#.#.....#.#...#t......#...#.#...#.......#
#.###B#.#.#.#.#.#######.###.#######.#.###.#######.#.#########.#.#####.###.#######
#.#q..#.#.#.#.#...#.....#...#.......#...#...#.#...#.........#.#.......#.#.#.....#
#.#.###.#.#.#.###.#.#####.#.#.#####.###.###.#.#.#####.#######.#########.#.###.#.#
#...#...#.#.#...#.#.......#...#.....#...#...#.........#.....#.......#.#...#m..#.#
#.#####.#.#####.#.#######.#########.#.###F#############.###.###.###.#.#.###.#####
#...#...#.......#.......#.#......h#.#...#.#.....#.......#.....#.#...#.#.#.......#
###.#.###########.#####.#.#.#####.#####.#.#.###.#.#####.#####.#.#.###G#.###.###.#
#.#.#.......#...#...#...#.#...J.#.#.....#.#...#.#.....#.#...#.#.#.#...#...#...#.#
#.#.#####.###.#.###.#####.#####.#.#.###.#.###.#.#####.#.#.#.#.###.#.#.###.#####S#
#w#...#...#...#...#...#...#...#.#...#...#.#...#.....#.#.#.#.#.....#.#...#.......#
#.###.#.###.#####.###.#.#####.#.#####.###.#.###.###.#.###.#.#######.###.#######.#
#...#...#...#.....#...#.#...#.#...#.#.#.#.#.#.#.#...#.....#...#...#.#.#.........#
#.#####.#.###.#####.###.#.#.#.###.#.#.#.#.#.#.#.###.#########.#.#.#.#.###########
#.......#...#.....#.#.....#...#.#.#...#.#...#.#...#.....#...#.#.#.#.....#.......#
#C#########.#####.#.#.#######.#.#.###.#.#.###.###.#####.#.###.#.#######.###.###.#
#.#.......#.#.#...#...#...#.....#...#...#.......#.#.....#.#...#.....#.#...#...#.#
#.###.#.#.#.#.#.###.###.#.#########.###.#####.###.#.#####.#.#####.#.#.###.###.###
#...#.#.#.#.#.#.#y..#...#...#.....#.#...#.....#...#.#.....#...#...#.....#...#...#
###.###.#I#.#.#.###########.#.###.#.#####.#####.###.#.###.#####.###########.#.#.#
#...#...#.#.#.#...........#...#...#.#...#...#...#.#...#...#.....#.........#.#.#.#
#.###.###.#.#.#####.###########.###.#.#.#####.###.#.#####.###.###.#######.#.###.#
#.....#...#...#...#.............#.....#.#.....#...#.#...#.....#...#.....#...#...#
#####.#######.#.#.###############.#####.#.#######.#.#.#.#####.#.###.###.#####.###
#.....#.....#...#.#...#.............#...#.......#...#.#.#.....#.#.#.#.#.........#
#.#####.###.#####.#.###.###########.#.###.#####.#####.#.#######.#.#.#.#########.#
#...#.#.#.#.......#...........#...#.#...#.....#.......#...#.....#...#.....#...#.#
###.#.#.#.###############.#####.#.#.###.#####.###########.#.#######.###.###.#.#.#
#...#.#...#.......#.....#.#.....#.#...#.#.....#...#.....#...#.....#.#...#...#...#
#.###.###.#.#####.#.###.###.#####.#####.#.#####.###.###.#####.###.#.#.###.#####.#
#.#.....#.#...#.....#...#...#.....#.....#...#.......#...#.....#.#.#...#...#.....#
#.###L#.#.#.#.#######.###.###.#####.###.###.#.#######.#.###.###.#.###.#.###.#####
#o..#.#.#.#.#.....#.#.#...#.#...#...#.#.#.#.#.....#...#.....#.#...#...#.#.......#
###.###.#.#######.#.#.#.#.#.###.#.###.#.#.#.#######.#########.#.#######.#######.#
#.#...#.#.......#.#.#.#.#.#.#...#.#...#.#.#.#...#...#.........#.#.....#.......#.#
#.###.#.#######.#.#.#.###.#.#.###.#.###.#.#.#.#.#.###.#######.#.#.###.#######.#.#
#.............#...#.......#.......#....@#@....#...#.........#.....#...........#.#
#################################################################################
#.....#.....#.#.........#.#...#.....#..@#@......#..u........#...#.......#.....Q.#
#.#.###.#.#.#.#.#######.#.#.#.#.#.###.#.#.#.###.#.#########.###.#.#.###.#######.#
#.#.#...#.#.#.#.....#...#.R.#.#.#.....#.#.#...#...#.......#r....#.#...#.........#
#.#.#.###.#.#.#####.###.#####.#.#######.#.###.#######.###.#####.#.###.#####.#####
#.#...#...#.......#...#.....#.#.#.#...#.#.#.#...#...#.#...#.....#b#.#...#...#..c#
#.#####.#############.#####.#.#.#.#.#.#.#.#.###.#.#.#.#.###.#####.#.###.#####.#.#
#p#...V.#..x#.......#...#...#.....#.#...#.#...#.#.#...#...#.#.#...#...#.....#.#.#
###.#####.#.#.#####.###.#.###U#####.###.#.#.#.#.#.#######.#.#.#.###.#.#####.#.#.#
#...#.....#.....#...#...#.#.#.#.....#.#.#...#.#.#.#...#.#.#...#...#.#.....#...#.#
#.###.###########.###.###.#.#.#.#####.#.#.#####.#.#.#.#.#.###.###.#.#####.#####.#
#.......#.......#...#.#.#.#...#...#.....#.#...#.#.#.#.#...#...#.#.#.....#...#.#.#
#.#####.#.#####.###.#.#.#.#.#####.#######.#.#.#.#.#H#.###.#.###.#.#.###.###.#.#.#
#.#...#.#.#...#.....#.#...#.....#...#...#.#.#...#.#.#...#.#.....#.#...#.#.#...#.#
#.#.#.###.#.#######.#.###.#########.#.#.###.#####.#.###.###.#####.#####.#.###.#.#
#.#.#.....#...#.....#...#.#.......#...#.#...#.....#.#.#.....#...#.......#.....#.#
#.#.#########.#.#######.#.#.#####.#####.#.###.#.###.#.#######.#.#########.#####.#
#.#.........#.#.#.#.....#...#...#.....#.#...#.#.#.........#...#...#.....#...#...#
#.#########.#.#.#.#.#########.#.#####.#.#.#.#.###.#########.###.###.#.#####.#.#.#
#.#.......#.#.#...#.#.......#.#.....#.#.#.#.#.....#.#.........#.#...#.#.....#.#.#
#.#######.#.#.###.#.###.#####.#####.#.#.#.#.###.###.#.#########.#.###.#.#####.#.#
#......z..#.#.#...#...#.....#.#.....#.#.#.#...#.....#.......#.#.#.#.#...#...#.#.#
#########.#.#.#.#######.###.#.#.###.#.#.#.###.###########.###.#.#.#.#######.#.#.#
#.#.......#.#...#.....#.#.#.#.#.#...#.#.#.#.#.............#...#.#.......#...#.#.#
#.#.#######.#.###.#.#.#.#.#.#.#.#.###.#.#.#.###############.###.#######.#.###.#.#
#...#.......#...#.#.#.#...#...#.#...#.#.#....j#...#...#....d#...#...#...#...#.#.#
#.###.#########.###.#.###.#####.#####.#.#####.#.###.#.#.#######.#.#.#.#####.#.#.#
#...#.#.......#.#...#...#...#.#.....#...#...#.#.....#.#.Z.#.....#.#...#.....#.#.#
#D###.#####.###.#.#####.###.#.#####.###.###.#.#######.###.###.###.#######.###.#.#
#.#...#...#..n#...#.N.#.#...#.....#.....#...#.....#...#.#...#.....#.....#.#...#.#
###.###.#.###.#######.#.#.#####.#.#######.#######.#.#.#.###.#.#####.###.#.#.###W#
#...#...#.............#.#.....#.#.....M.#.#.......#.#...#...#.......#.....#...#.#
#.###.#.###############.#####.###.#####.#.#.#######.###.#.#######.#####.#####.#.#
#.#.P.#...#...#.......#.#...#.....#...#.#.#...#.....#...#...#.#...#...#.#.....#i#
#.#######.#.#.#.#####.#.#.#.#######.#.#.#.###.###.###.#####.#.#.###.#.###.#####.#
#.......#...#.......#...#.#.......#.#...#...#....f#.E.#...#.#.....#.#.#...#.O.#.#
#.#####.#################.###.#####.#####.#########.#####.#.#######X#.#.###.#.###
#.#.#...#...#...T...#.A.#...#..k..#.#...#.#...#...#.#...#.#.....#...#.#.....#...#
#.#.#.###.#.#.#####.#.#.###.#####.#.#.#.#.#.#.#.#.#.#.#.#.#####.#.###.#########.#
#...#.....#.......#...#.........#.Y...#.#..s#...#..g..#.......#v..#............l#
#################################################################################";

    private static int numberOfLines;
    private static int numberOfColumns;
    private static IList<string> map;

    static HashSet<char> lowercase = new HashSet<char>("abcdefghijklmnopqrstuvwxyz");
    static HashSet<char> uppercase = new HashSet<char>("ABCDEFGHIJKLMNOPQRSTUVWXYZ");

    public override Task ExecuteAsync()
    {
        long minSteps = long.MaxValue;
        map = input.Split(new[] {Environment.NewLine}, StringSplitOptions.None);
        numberOfLines = map.Count;
        IList<(int, int)> locations = new List<(int, int)>();
        int l = 0;
        foreach (var line in map)
        {
            numberOfColumns = line.Length;
            int c = 0;
            foreach (var v in line)
            {
                if (v == '@')
                {
                    locations.Add((l,c));
                }

                c++;
            }

            l++;
        }

        var state = new State
        {
            Location1 = locations[0],
            Location2 = locations[1],
            Location3 = locations[2],
            Location4 = locations[3]
        };
        state.Solve(ref minSteps);

        Result = minSteps.ToString();

        return Task.CompletedTask;
    }

    private class State
    {
        public (int, int) Location1 { get; set; }
        public (int, int) Location2 { get; set; }
        public (int, int) Location3 { get; set; }
        public (int, int) Location4 { get; set; }
        public long NumberOfSteps { get; set; }
        public IList<char> KeysFound { get; set; } = new List<char>();


        public void Solve(ref long minSteps)
        {
            var keysToBeFound = new Dictionary<char, (long, int, int)>();
            AddKeysToBeFound(Location1, keysToBeFound);
            AddKeysToBeFound(Location2, keysToBeFound);
            AddKeysToBeFound(Location3, keysToBeFound);
            AddKeysToBeFound(Location4, keysToBeFound);
            if (!keysToBeFound.Any())
            {
                if (NumberOfSteps < minSteps)
                {
                    minSteps = NumberOfSteps;
                    Console.WriteLine(NumberOfSteps);
                }
            }

            foreach (var keyValuePair in keysToBeFound.OrderBy(k => k.Value.Item1))
            {
                if (NumberOfSteps + keyValuePair.Value.Item1 < minSteps)
                {
                    var newState = new State
                    {
                        Location1 = Location1,
                        Location2 = Location2,
                        Location3 = Location3,
                        Location4 = Location4,
                        NumberOfSteps = NumberOfSteps + keyValuePair.Value.Item1,
                        KeysFound = KeysFound.ToList()
                    };
                    if (keyValuePair.Value.Item2 < 40)
                    {
                        if (keyValuePair.Value.Item3 < 40)
                        {
                            newState.Location1 = (keyValuePair.Value.Item2, keyValuePair.Value.Item3);
                        }
                        else
                        {
                            newState.Location2 = (keyValuePair.Value.Item2, keyValuePair.Value.Item3);
                        }
                    }
                    else
                    {
                        if (keyValuePair.Value.Item3 < 40)
                        {
                            newState.Location3 = (keyValuePair.Value.Item2, keyValuePair.Value.Item3);
                        }
                        else
                        {
                            newState.Location4 = (keyValuePair.Value.Item2, keyValuePair.Value.Item3);
                        }
                    }
                    newState.KeysFound.Add(keyValuePair.Key);
                    newState.Solve(ref minSteps);
                }
                else
                {
                    break;
                }
            }
        }

        private void AddKeysToBeFound((int, int) location, Dictionary<char, (long, int, int)> result)
        {
            var hash = new HashSet<(int, int)> { location };
            IList<(int, int)> lastAdded = new List<(int, int)> { location };
            bool added = true;
            long step = 0;
            while (added)
            {
                step++;
                added = false;
                IList<(int, int)> newLastAdded = new List<(int, int)>();
                foreach (var square in lastAdded)
                {
                    foreach (var newSquare in Neighbours())
                    {
                        if (hash.Contains(newSquare))
                        {
                            continue;
                        }

                        hash.Add(newSquare);
                        char value = map[newSquare.Item1][newSquare.Item2];
                        if (value == '#')
                        {
                            continue;       
                        }
                        if (value == '.' || value == '@' || IsOpenDoor() || IsTakenKey())
                        {
                            newLastAdded.Add(newSquare);
                            added = true;
                        }

                        if (IsNonTakenKey())
                        {
                            result.Add(value, (step, newSquare.Item1, newSquare.Item2));
                        }

                        bool IsNonTakenKey()
                        {
                            return lowercase.Contains(value) && !IsTakenKey();
                        }

                        bool IsTakenKey()
                        {
                            return KeysFound.Contains(value);
                        }

                        bool IsOpenDoor()
                        {
                            if (uppercase.Contains(value) && KeysFound.Contains((char)(value + 32)))
                            {
                                return true;
                            }

                            return false;
                        }
                    }

                    IEnumerable<(int, int)> Neighbours()
                    {
                        if (square.Item1 > 0)
                        {
                            yield return (square.Item1 - 1, square.Item2);
                        }

                        if (square.Item1 < numberOfLines)
                        {
                            yield return (square.Item1 + 1, square.Item2);
                        }

                        if (square.Item2 > 0)
                        {
                            yield return (square.Item1, square.Item2 - 1);
                        }

                        if (square.Item2 < numberOfColumns)
                        {
                            yield return (square.Item1, square.Item2 + 1);
                        }
                    }
                }

                lastAdded = newLastAdded;
            }
        }
    }



    public override int Nummer => 201918;
}